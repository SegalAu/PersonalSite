{"ast":null,"code":"'use strict';\n\nconst toposort = require('toposort');\n\nconst _ = require('lodash');\n/**\r\n  Sorts dependencies between chunks by their \"parents\" attribute.\r\n\r\n  This function sorts chunks based on their dependencies with each other.\r\n  The parent relation between chunks as generated by Webpack for each chunk\r\n  is used to define a directed (and hopefully acyclic) graph, which is then\r\n  topologically sorted in order to retrieve the correct order in which\r\n  chunks need to be embedded into HTML. A directed edge in this graph is\r\n  describing a \"is parent of\" relationship from a chunk to another (distinct)\r\n  chunk. Thus topological sorting orders chunks from bottom-layer chunks to\r\n  highest level chunks that use the lower-level chunks.\r\n\r\n  @param {Array} chunks an array of chunks as generated by the html-webpack-plugin.\r\n  - For webpack < 4, It is assumed that each entry contains at least the properties\r\n  \"id\" (containing the chunk id) and \"parents\" (array containing the ids of the\r\n  parent chunks).\r\n  - For webpack 4+ the see the chunkGroups param for parent-child relationships\r\n\r\n  @param {Array} chunks an array of ChunkGroups that has a getParents method.\r\n  Each ChunkGroup contains a list of chunks in order.\r\n\r\n  @return {Array} A topologically sorted version of the input chunks\r\n*/\n\n\nmodule.exports.dependency = (chunks, options, compilation) => {\n  const chunkGroups = compilation.chunkGroups;\n\n  if (!chunks) {\n    return chunks;\n  } // We build a map (chunk-id -> chunk) for faster access during graph building.\n\n\n  const nodeMap = {};\n  chunks.forEach(chunk => {\n    nodeMap[chunk.id] = chunk;\n  }); // Next, we add an edge for each parent relationship into the graph\n\n  let edges = [];\n\n  if (chunkGroups) {\n    // Add an edge for each parent (parent -> child)\n    edges = chunkGroups.reduce((result, chunkGroup) => result.concat(Array.from(chunkGroup.parentsIterable, parentGroup => [parentGroup, chunkGroup])), []);\n    const sortedGroups = toposort.array(chunkGroups, edges); // flatten chunkGroup into chunks\n\n    const sortedChunks = sortedGroups.reduce((result, chunkGroup) => result.concat(chunkGroup.chunks), []).map(chunk => // use the chunk from the list passed in, since it may be a filtered list\n    nodeMap[chunk.id]).filter((chunk, index, self) => {\n      // make sure exists (ie excluded chunks not in nodeMap)\n      const exists = !!chunk; // make sure we have a unique list\n\n      const unique = self.indexOf(chunk) === index;\n      return exists && unique;\n    });\n    return sortedChunks;\n  } else {\n    // before webpack 4 there was no chunkGroups\n    chunks.forEach(chunk => {\n      if (chunk.parents) {\n        // Add an edge for each parent (parent -> child)\n        chunk.parents.forEach(parentId => {\n          // webpack2 chunk.parents are chunks instead of string id(s)\n          const parentChunk = _.isObject(parentId) ? parentId : nodeMap[parentId]; // If the parent chunk does not exist (e.g. because of an excluded chunk)\n          // we ignore that parent\n\n          if (parentChunk) {\n            edges.push([parentChunk, chunk]);\n          }\n        });\n      }\n    }); // We now perform a topological sorting on the input chunks and built edges\n\n    return toposort.array(chunks, edges);\n  }\n};\n/**\r\n * Sorts the chunks based on the chunk id.\r\n *\r\n * @param  {Array} chunks the list of chunks to sort\r\n * @return {Array} The sorted list of chunks\r\n */\n\n\nmodule.exports.id = chunks => chunks.sort(function orderEntryLast(a, b) {\n  if (a.entry !== b.entry) {\n    return b.entry ? 1 : -1;\n  } else {\n    return b.id - a.id;\n  }\n});\n/**\r\n * Performs identity mapping (no-sort).\r\n * @param  {Array} chunks the chunks to sort\r\n * @return {Array} The sorted chunks\r\n */\n\n\nmodule.exports.none = chunks => chunks;\n/**\r\n * Sort manually by the chunks\r\n * @param  {Array} chunks the chunks to sort\r\n * @return {Array} The sorted chunks\r\n */\n\n\nmodule.exports.manual = (chunks, options) => {\n  const specifyChunks = options.chunks;\n  const chunksResult = [];\n  let filterResult = [];\n\n  if (Array.isArray(specifyChunks)) {\n    for (var i = 0; i < specifyChunks.length; i++) {\n      filterResult = chunks.filter(chunk => {\n        if (chunk.names[0] && chunk.names[0] === specifyChunks[i]) {\n          return true;\n        }\n\n        return false;\n      });\n      filterResult.length > 0 && chunksResult.push(filterResult[0]);\n    }\n  }\n\n  return chunksResult;\n};\n/**\r\n * Defines the default sorter.\r\n */\n\n\nmodule.exports.auto = module.exports.id; // In webpack 2 the ids have been flipped.\n// Therefore the id sort doesn't work the same way as it did for webpack 1\n// Luckily the dependency sort is working as expected\n\nif (Number(require('webpack/package.json').version.split('.')[0]) > 1) {\n  module.exports.auto = module.exports.dependency;\n}","map":null,"metadata":{},"sourceType":"script"}